## Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Дубровин Д.К.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие подходы обычно применяются для обработки естественных и искусственных языков?
Почему Prolog оказывается удобным языком для решения таких задач?

Обработка естественного языка - является общим направлением для развития искуственного интеллекта и математической лингвистики, данное направление изучает проблемы компьютерного анализа, а также синтеза естестественных языков. Для примера подобных проблем можно привести обработку русского языка: только свободный порядок слов в нашем языке может привнести пару сюрпризов в алгоритм. На данный момент существует множество методов для решения задач обработки языков: метод машинного перевода, токенизация предложений, векторный и так далее.

Prolog позволяет при уже написанной грамматике языка получить уже почти готовый текстовый анализатор. Другими словами Prolog довольно неплох при создании парсеров, так как объекты языка будут написаны в предикатах, что позволяет нам ввести правила обработки. (Для масштабирования подобного прроекта необходимо просто ввести новое слово или символ при необходимости) Хочется заметить, что Prolog можно также использовать для генерации отчетов.

## Задание

Вариант 9. Реализовать разбор фраз языка (вопросов), выделяя в них неизвестный объект\

```
 Запрос:    ?- an_q(['Кто', 'любит', 'шоколад', '?'], X).
            ?- an_q(['Где', 'лежат', 'деньги', '?'], X).
            ?- an_q(['Что', 'любит', 'Даша', '?'], X).
 Результат: X='любить'(agent(Y), object('шоколад')),
            X='лежать'(object('деньги'), loc(X)),
            X='любить'(agent("Даша"), object(Y)).
```
## Принцип решения

В данном блоке я прописываю основной словарь для моего языка, выделяя туда неизвестные фразы (объекты):
```
agent_list(['Даша','Света','Саша','Коля','Катя','Маша']).
verb_list(['любит','хочет','кушает','лежат']).
obj_list(['деньги','шоколад','фильмы','книги','мандарины']).
```

Предикат для глаголов, использующихся в словаре:
```
an_verb('любит','любить').
an_verb('хочет','хотеть').
an_verb('кушает','кушать').
an_verb('лежат','лежать','лежит').
```

Описываю предикаты для обработки объектов, а также глаголов словаря:
```
an_v([X],Y):- 
verb_list(L),
member(X,L),
an_verb(X,Y).

an_s1([X],object(X)):- 
obj_list(L),
member(X,L).

an_s2([X],agent(X)):- 
agent_list(L),
member(X,L).
```

Здесь формируется основной предикат для решения поставленной задачи, он будет каждым для своего вопроса - кто, что и где. А после уже создается ответ с помощью предиката для обработки каждой группы слов.
```
an_q(L,(Y,X,Z)):-
member('Кто',L),
member('?',L),
my_remove('?',L,NewL),
my_remove('Кто',NewL,NewL2),
append(L1,L2,NewL2),
an_v(L1,Y),
an_s1(L2,Z),
X = agent('Y').

an_q(L,(Y,Z,X)):-
member('Что',L),
member('?',L),
my_remove('?',L,NewL),
my_remove('Что',NewL,NewL2),
append(L1,L2,NewL2),
an_v(L1,Y),
an_s2(L2,Z),
X = object('Y').

an_q(L,(Y,Z,X)):-
member('Где',L),
member('?',L),
my_remove('?',L,NewL),
my_remove('Где',NewL,NewL2),
append(L1,L2,NewL2),
an_v(L1,Y),
an_s1(L2,Z),
X = loc('Y').
```

## Результаты

```
?- an_q(['Кто', 'любит', 'шоколад', '?'], X).
X =  (любить, agent('Y'), object(шоколад)) ;
false.

?- an_q(['Кто', 'кушает', 'мандарины', '?'], X).
X =  (кушать, agent('Y'), object(мандарины)) 
Unknown action: ю (h for help)
Action? .

?- an_q(['Где', 'лежат', 'мандарины', '?'], X).
X =  (лежать, object(мандарины), loc('Y')) 
Unknown action: ю (h for help)
Action? .

?- an_q(['Где', 'лежит', 'Саша', '?'], X).
false.
```

## Выводы
В данной лабораторной работе я столкнулся с совершенно новым для себя понятием - обработка естественного языка. Из работы я сделал вывод, что методы применяемые для Prolog более удобны, чем могут предложить императивные или функциональные языки программирования. В основном его главное преимущества - это разделение исходного текста на составные части, что дает нам возможность обрабатывать их рекурсивно и нехависимо друг от друга. Это обусловлено декларативной семантикой языка, а также тем что правила грамматики напрямую записываются и считываются с помощью предикатов Prolog.
Однако и у Prolog существуют свои разумные недостатки и ограничения, для примера можно привести память при использовании Prolog в реальных задачах, так как алфавит там скорее весго будет представлен в более обширном виде.
