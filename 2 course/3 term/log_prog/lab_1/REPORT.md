# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Дубровин Д.К.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение
Списки в Prolog довольно сильно отличаются от привычных списков в императивных языках программирования. Если в Prolog конструкция списка выглядит так -> это односвязная структура данных, разделенная на так называемую "head" - "голову" и "tail" - "хвост". Стоит заметить, что "голова" списка единичный узел, а вот хвост может состоять из нескольких элементов. Как я написал ранее, списки односвязные, а это означает, что в каждый узел имеет некоторые данные и указатель на следующий за ним элемент списка.\
  ![Imgur](https://i.imgur.com/4633SmS.jpeg)
  Работа с такой структурой строго последовательная, мы получаем доступ к каждому элементу списка поочередно. Такрй вариант обработки похож на работу с массивами.

## Задание 1.1: Предикат обработки списка

**Стандартные предикаты обработки списков**

***Предикат для получения длины списка***\
Формат ввода(список, длина)
```
length_([], 0).
length_([_|A], N) :- length_(A, N1), N is N1 + 1.
```
***Предикат проверки вхождения элемента в список***\
Формат ввода(элемент, список)
```
member(A, [A|_]). 
member(A, [_|B]) :- member(A, B).
```
***Предикат объединения списков***\
Формат ввода(список1, список2, список1+2)
```
append([], List2, List2).
append([H|T], List2, [H|TR]) :- append(T, List2, TR).
```
***Предикат удаления элемента из списка***\
Формат ввода(элемент, список, список без элемента)
```
remove([], _Elem, []).
remove([Elem|T], Elem, TR) :- remove(T, Elem, TR), !.
remove([H|T], Elem, [H|TR]) :- remove(T, Elem, TR).
```
***Предикат проверки перестановки списка***\
Формат ввода(список, перестановка)
```
permute([],[]).
permute(L,[X|T]) :- remove(L,X,R), permute(R,T).
```
***Предикат проверки подсписка***\
Формат ввода(подсписок, список)
```
sub_start([], _List).
sub_start([H|TSub], [H|TList]) :- sub_start(TSub, TList).
sublist(Sub, List) :- sub_start(Sub, List), !.
sublist(Sub, [_H|T]) :- sublist(Sub, T).
```

### Предикаты обработки списков

***Вариант 9: Получение N-го элемента списка***


***Без использования стандартных предикатов:***
```
find(1,[Result|_],Result):-!.
find(Number,[_|Tail],Result):-N is Number-1,find(N,Tail,Result).
```
В основе моего предиката лежит простая рекурсия. При поиска Head - вывожу ее сразу, а когда запрашивается элемент из Tail, ищу рекурсивно элемент, который был до него N = Number - 1.\
\
***С использованием стандартных предикатов:***
```
?- nth0(1,[1, 2, 3],Elem).
Elem = 2.
?- nth0(0,[1, 2, 3],Elem).
Elem = 1.
```
Данный стандартный предикат позволяет получить элемент списка по его индексу. Индексация начинается с нуля.

## Задание 1.2: Предикат обработки числового списка

***Проверка списка на геометрическую прогрессию***

Примеры использования:
```
?- geom([1,3,9,27]).
true.

?- geom([1,3,9,17]).
false.

?- geom([1,2,4,8,16,32]).
true.
```
Реализация: после вызова предиката -? geom([list]). я выделяю два первых числа из списка и вычисляю N = S/F, после чего рекурсивно прохожусь по остальному списку проверяя является ли следующий элемент списка произведением предыдущего и уже вычисленного мною N. (Если список состоит из одного элемента, я также обрабатываю этот случай)
```
pregeom([F],N):-number(F),!.
pregeom([F,S|Tail],N):-number(F),number(S),S =:= F*N,pregeom([S|Tail],N).
geom([F]):-number(F),!.
geom([F,S|Tail]):-number(F),number(S),N is S/F,pregeom([S|Tail],N).
```

**Пример совместного использования:**
Вывод всевозможных перестановок, если список является геометрической прогрессией.
```
test(List,R):-
    geom(List),
    permutation(List,R).  
```
**Результат вывода:**
```
?- test([1,2,4],X).
X = [1, 2, 4] ;
X = [1, 4, 2] ;
X = [2, 1, 4] ;
X = [2, 4, 1] ;
X = [4, 1, 2] ;
X = [4, 2, 1] ;
false.
```

## Задание 2: Реляционное представление данных

**Преимущества реляционного представления:**

1) удобный для представления и понимания вид изложения информации. Вся информация имеет одинаковую структуру (в таблицах), а также хочу заметить, что имена предикатов позволяют понять отношения к тем или иным данным;
2) изменение в программе, если изменена база данных, будут минимальны

**Недостатки:**
1) низкая скорость доступа к данным из-за достаточно большого объема, который занимает БД;
2) трудности с изменением самой БД, если учесть, что один и тот же параметр нужно изменить во всех столбцах таблицы;
3) сложности в процессе проектирования - нужно будет точно понимать предназначение данной БД

Я выбрал файл three.pl из-за довольно удобного варианта представления данных, в представленном файле вся информация о студентах выглядит довольно компактно и понятно для восприятия. Также при поиске той или иной информации, мне не придется перебирать огромное количество фактов, как это происходит в файлах one.pl и two.pl. Я думаю, что в данной работе именно файл three.pl идеально откалиброван между перебором большого количества фактов и огромного количества данных о каждом факте.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

Вариант 1:
1) Получить таблицу групп и средний балл по каждой из групп;
2) Для каждого предмета получить список студентов, не сдавших экзамен (grade=2);
3) Найти количество не сдавших студентов в каждой из групп

Определяю кодировку и добавляю файл three.pl
```
:- set_prolog_flag(encoding, utf8).
:- ['three.pl'].
```
**Задание 1: Получить таблицу групп и средний балл по каждой из групп**

Предикат для вывода элементов списка на отдельных строках
```
print_list([]). 
print_list([H|T]) :-
    write(H),
    write('\n'),
    print_list(T).
```
Предикат для объединения списков
```
append1([], List2, List2). 
append1([Head|Tail], List2, [Head|TailResult]):-
   append1(Tail, List2, TailResult).
```
Предикат получения списка со всеми оценками группы
```
group_grades_list(Num, L) :- 
    findall(X, student(Num, _, [grade('LP',X),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), LP),
    findall(X, student(Num, _, [grade('LP',_),grade('MTH',X),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), MTH),
    findall(X, student(Num, _, [grade('LP',_),grade('MTH',_),grade('FP',X),grade('INF',_),grade('ENG',_),grade('PSY',_)]), FP),
    findall(X, student(Num, _, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',X),grade('ENG',_),grade('PSY',_)]), INF),
    findall(X, student(Num, _, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',X),grade('PSY',_)]), ENG),
    findall(X, student(Num, _, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',X)]), PSY),
    append1(LP, MTH, A),
    append1(FP, INF, B),
    append1(ENG, PSY, C),
    append1(A, B, D),
    append1(C, D, L).
```

Предикат суммы элементов списка
```
sum_list([],0). 
sum_list([H|T], S) :-
	sum_list(T, S1), 
	S is H + S1.
```

Предикат нахождения суммы оценок студентов группы группы
```
group_grades_sum(Num, Sum) :- 
    group_grades_list(Num, L),
    sum_list(L, Sum).
```

предикат нахождения средней оценки группы
```
group_grades_av(Num, Av) :- 
    group_grades_sum(Num, Sum),
    group_grades_list(Num, L),
    length(L, Le),
    Av is Sum / Le.
```
Предикат вывода средних оценок всех групп
```
all_groups_grades_av() :- 
    write("Средние оценки 101 группы: "),
    group_grades_av(101, A),
    write(A),
    write('\n'),
    write("Средние оценки 102 группы: "),
    group_grades_av(102, B),
    write(B),
    write('\n'),
    write("Средние оценки 103 группы: "),
    group_grades_av(103, C),
    write(C),
    write('\n'),
    write("Средние оценки 104 группы: "),
    group_grades_av(104, D),
    write(D),
    write('\n').
```

Предикат нахождения списка студентов группы 
```
group_list(Num, L) :- 
    findall(X, student(Num, X, _), L). 
```
Предикат вывода списков всех групп
```
group_table() :- 
    write("\nГруппа 101:\n"),
    group_list(101, A),
    print_list(A),
    write("\nГруппа 102:\n"),
    group_list(102, B),
    print_list(B),
    write("\nГруппа 103:\n"),
    group_list(103, C),
    print_list(C),
    write("\nГруппа 104:\n"),
    group_list(104, D),
    print_list(D),
    write('\n').
```

Предикат, который собирает все остальные и выполняет задание 1
```
task1() :- 
    group_table(),
    all_groups_grades_av().
```

**Задание 2: Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)**

Предикаты для получения списка студентов не сдавших определенный экзамен (получили оценку 2)
```
lp_grade2_list(L) :- 
    findall(X, student(_, X, [grade('LP',2),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), L).

mth_grade2_list(L) :-
    findall(X, student(_, X, [grade('LP',_),grade('MTH',2),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), L).

fp_grade2_list(L) :-
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',2),grade('INF',_),grade('ENG',_),grade('PSY',_)]), L).

inf_grade2_list(L) :-
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',2),grade('ENG',_),grade('PSY',_)]), L).

eng_grade2_list(L) :-
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',2),grade('PSY',_)]), L).

psy_grade2_list(L) :-
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',2)]), L).
```
Предикат, выполняющий задание 2
```
task2() :- 
    write("\nСтуденты, которые не сдали -логическое программирование- :\n"),
    lp_grade2_list(A),
    print_list(A),
    write("\nСтуденты, которые не сдали -математический анализ- :\n"),
    mth_grade2_list(B),
    print_list(B),
    write("\nСтуденты, которые не сдали -функциональное программирование- :\n"),
    fp_grade2_list(C),
    print_list(C),
    write("\nСтуденты, которые не сдали -информатику- :\n"),
    inf_grade2_list(D),
    print_list(D),
    write("\nСтуденты, которые не сдали -английский язык- :\n"),
    eng_grade2_list(E),
    print_list(E),
    write("\nСтуденты, которые не сдали -психологию- :\n"),
    psy_grade2_list(F),
    print_list(F).
```

**Задание 3: Найти количество не сдавших студентов в каждой из групп**

Предикат для удаления элемента из списка
```
delete([], _Elem, []):-!. 
delete([Elem|Tail], Elem, ResultTail):-
   delete(Tail, Elem, ResultTail), !.
delete([Head|Tail], Elem, [Head|ResultTail]):-
   delete(Tail, Elem, ResultTail).
```

Предикат удаления всех элементов списка2 из списка1
```
delete_list([], _, []). 
delete_list(L, [], L).
delete_list(L, [H2|T2], Res) :-
    delete(L, H2, Res2),
    delete_list(Res2, T2, Res).
```

Предикат для нахождения числа сдавших все экзамены в группе
```
group_amount(Num, Am) :- 
    group_list(Num, L),
    lp_grade2_list(LP),
    mth_grade2_list(MTH),
    fp_grade2_list(FP),
    inf_grade2_list(INF),
    eng_grade2_list(ENG),
    psy_grade2_list(PSY),
    append1(LP, MTH, A),
    append1(FP, INF, B),
    append1(ENG, PSY, C),
    append1(A, B, D),
    append1(C, D, N),
    delete_list(L, N, R),
    length(R, Am).
```

Предикат, выполняющий третье подзадание из трёх
```
task3() :- 
    write("\nКоличество студентов в 101 группе, которые провалились на экзамене: "),
    group_amount(101, Am1),
    group_list(101, L1),
    length(L1, A1),
    X is A1 - Am1,
    write(X),
    write("\nКоличество студентов в 102 группе, которые провалились на экзамене: "),
    group_amount(102, Am2),
    group_list(102, L2),
    length(L2, A2),
    Y is A2 - Am2,
    write(Y),
    write("\nКоличество студентов в 103 группе, которые провалились на экзамене: "),
    group_amount(103, Am3),
    group_list(103, L3),
    length(L3, A3),
    Z is A3 - Am3,
    write(Z),
    write("\nКоличество студентов в 104 группе, которые провалились на экзамене: "),
    group_amount(104, Am4),
    group_list(104, L4),
    length(L4, A4),
    W is A4 - Am4,
    write(W),
    write('\n').
```
**Выполнение задания (ввод в консоль):**
```
%Tests:
?- task1().
?- task2().
?- task3().
```
Вывод:
```
?- task1().

Группа 101:
Петровский
Сидоров
Мышин
Безумников
Густобуквенникова

Группа 102:
Петров
Ивановский
Биткоинов
Шарпин
Эксель
Текстописов
Криптовалютников
Азурин
Круглотличников

Группа 103:
Сидоркин
Эфиркина
Сиплюсплюсов
Программиро
Клавиатурникова
Решетников
Текстописова
Вебсервисов

Группа 104:
Иванов
Запорожцев
Джаво
Фулл
Круглосчиталкин
Блокчейнис

Средние оценки 101 группы: 4
Средние оценки 102 группы: 3.814814814814815
Средние оценки 103 группы: 3.7708333333333335
Средние оценки 104 группы: 3.888888888888889
true.

?- task2().

Студенты, которые не сдали -логическое программирование- :

Студенты, которые не сдали -математический анализ- :
Клавиатурникова
Блокчейнис
Азурин

Студенты, которые не сдали -функциональное программирование- :
Сидоркин
Мышин
Шарпин

Студенты, которые не сдали -информатику- :
Клавиатурникова
Текстописов
Блокчейнис

Студенты, которые не сдали -английский язык- :
Петровский
Круглосчиталкин

Студенты, которые не сдали -психологию- :
Запорожцев
Сидоров
Мышин
true.

?- task3().

Количество студентов в 101 группе, которые провалились на экзамене: 3
Количество студентов в 102 группе, которые провалились на экзамене: 3
Количество студентов в 103 группе, которые провалились на экзамене: 2
Количество студентов в 104 группе, которые провалились на экзамене: 3
true .
```

## Выводы

Во время выполнения данной лабораторной работы я познакомился с основами логического программирования на языке Пролог. Изучение стандартных предикатов, структуры данных типа "список" и методам работы с ней - это те цели, которые преследовала данная работа. Для меня было довольно необычно переключить свой тип мышления с императивного языка на на логический. Я думаю, чтобы ускорить процесс адаптации необходима практика, чтобы буквально на пальцах понимать, как и что здесь работает. Я пока не могу понять почему для подобных задач, как в этой лабораторной работе, нужно использовать именно prolog, а не любой другой императивный язык, но думаю, что это ждет меня в будущем.

