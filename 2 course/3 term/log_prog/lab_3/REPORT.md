#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Дубровин Д.К.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |



## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? 
Почему Prolog оказывается удобным языком для решения таких задач?

Довольно большое количество задач в интелектуальных системах подходят для решения их методом поиска в пространстве состояний. В данном случае стоит обратить внимание на то, что результат данного поиска - это и есть решение, для примера можно привести любую головоломку - Кубик Рубика. Пространство состояний возникает, когда происходит разбиение исходной задачи на отдельные шаги. Поиск же зависит от выбранного алгоритма. Для примера, поиск в глубину, мы делаем некий шаг от изначального состояния, далее новый из нового и так далее, пока не достигнем искомого или же наткнемся на состояние, когда не будет выполняться условие. После чего рекурсивно вернемся назад и повторим действия, пока не найдем решение.

В текущей лабораторной мы будем использовать 3 алгоритма поиска: в глубину, в ширину, а также поиск с итеративным погружением.

Prolog удобен для решения подобных задач, потому что его собственные механизмы очень похожи с методами применяемыми для нахождения решения. Также стоит отметить, что в Prolog очень легко и удобно описать условия пространства состояний необходимых по задаче. 

## Задание
Номер по списку: 8\
***Вариант 1***\
***Задание***: Крестьянину нужно переправить волка, козу и капусту с левого берега реки на правый. Как это сделать
за минимальное число шагов, если в распоряжении крестьянина имеется двухместная лодка, и нельзя
оставлять волка и козу или козу и капусту вместе без присмотра человека. 

## Принцип решения

Для решения этой задачи мне необходимо написать набор переходов между состояниями. В самом начале я описываю условия, сказанные в самой задаче, а именно, что коза и капуста не могут находиться на одном береге одновременно, также что коза и волк не могут находиться вместе на одном береге.
```
exception('Коза', 'Волк').
exception('Волк', 'Коза').
exception('Коза', 'Капуста').
exception('Капуста', 'Коза').
```
Добавление элемента:
```
add(E, [], [E]).
add(E, [H|T], [H|T1]) :- add(E, T, T1).
```
Вывод списка Res:
```
printRes([]).
printRes([A|T]) :- printRes(T), write(A), nl.
```
Предикат для проверки правильности условия задачи:
```
check([Item1, Item2]) :- exception(Item1, Item2).
```
Я хочу с помощью предиката move получать новое состояние. Состояние s(L,X,R):\
L - состояние левого берега\
X - состояние лодки (L - левый берег/R - правый берег)\
R - состояние правого списка\
Состояния берегов являются списками, в которых перечесляются животные находящиеся на данном берегу. Соответственно, для перехода из начального состояния, возможны 3 варианта:
```
move(s([Item1, Item2, Item3], 'L', []), s([Item1, Item2], 'R', [Item3])) :- not(check([Item1, Item2])).
move(s([Item1, Item2, Item3], 'L', []), s([Item1, Item3], 'R', [Item2])) :- not(check([Item1, Item3])).
move(s([Item1, Item2, Item3], 'L', []), s([Item2, Item3], 'R', [Item1])) :- not(check([Item2, Item3])).
```
В случае, когда лодка находится на правом берегу и такде на нем находятся 2 объекта, которые могу надится друг с другом, то лодка переходит на другой берег:
```
move(s([Left|T], 'R', Right), s([Left|T], 'L', Right)) :- not(check(Right)).
move(s(Left, 'R', [Item1, Item2]), s(Out, 'L', [Item2])) :- check([Item1, Item2]), add(Item1, Left, Out).
```
Перемещение объектов:
```
move(s([L|LT], 'L', [R|RT]), s(LT, 'R', Out)) :- add(L, [R|RT], Out).
move(s([X, L|LT], 'L', [R|RT]), s([X|LT], 'R', Out)) :- add(L, [R|RT], Out).
```
Предикат prolong нужен для того, чтобы продлить все пути в графе, а также предотвратить зацикливания:
```
prolong([In|InT], [Out, In|InT]) :- move(In, Out), not(member(Out, [In|InT])).
```
Поиск в глубину:
```
int(1).
int(X) :- int(Y), X is Y + 1.

dpth([X|T], X, [X|T]).
dpth(P, F, L) :- prolong(P, P1), dpth(P1, F, L).

deapth_search(A, B) :-
    write('deapth_search START'), nl,
    get_time(Time1),
    dpth([A], B, L),
    printRes(L),
    get_time(Time2),
    write('deapth_search END'), nl, nl,
    Time is Time1 - Time2,
    write('TIME IS '), write(T1), nl, nl.
```
Предикат для поиска в ширину:
```
bdth([[B|T]|_], B, [B|T]).
bdth([H|QT], X, R) :-
    findall(Z, prolong(H, Z), T),
    append(QT, T, OutQ), !,
    bdth(OutQ, X, R).
bdth([_|T], X, R) :- bdth(T, X, R).

bdth_search(X, Y) :-
    write('bdth_search START'), nl,
    get_time(Time1),
    bdth([[X]], Y, L),
    printRes(L),
    get_time(Time2),
    write('bdth_search END'), nl, nl,
    Time is Time1 - Time2,
    write('TIME IS '), write(T1), nl, nl.
```
Предикат для поиска с итерационным углублением:
```
depthId([Finish|T], Finish, [Finish|T], 0).
depthId(Path, Finish, R, N) :-
    N > 0,
    prolong(Path, NewPath),
    N1 is N - 1,
    depthId(NewPath, Finish, R, N1).

iter_search(Start, Finish) :-
    write('iter_search START'), nl,
    get_time(Time1),
    int(DepthLimit),
    depthId([Start], Finish, Res, DepthLimit),
    printRes(Res),
    get_time(Time2),
    write('iter_search END'), nl, nl,
    Time is Time1 - Time2,
    write('TIME IS '), write(T1), nl, nl.
iter_search(Start, Finish, Path) :- int(Level), iter_search(Start, Finish, Path, Level).
```

## Результаты

! Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-------------------------------------------------------------------|
| В глубину       |             7                  | 0.02843419596  |
| В ширину        |             7                  | 0.00013279914  |
| Iter            |             7                  | 0.00017690658  |

Пример работы поиска в глубину:
```
?- deapth_search(s(['Волк','Коза','Капуста'],'L',[]),s([],'R',[_,_,_])).
searchDpth START
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Капуста],R,[Коза,Волк])
s([Капуста,Коза],L,[Волк])
s([Коза],R,[Волк,Капуста])
s([Коза],L,[Волк,Капуста])
s([],R,[Волк,Капуста,Коза])
searchDpth END

TIME IS 4.220008850097656e-5

true ;
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Капуста],R,[Коза,Волк])
s([Капуста,Коза],L,[Волк])
s([Капуста],R,[Волк,Коза])
s([Капуста,Волк],L,[Коза])
s([Волк],R,[Коза,Капуста])
s([Волк,Коза],L,[Капуста])
s([Коза],R,[Капуста,Волк])
s([Коза],L,[Капуста,Волк])
s([],R,[Капуста,Волк,Коза])
searchDpth END

TIME IS 1.70725679397583

true ;
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Волк],R,[Коза,Капуста])
s([Волк,Коза],L,[Капуста])
s([Коза],R,[Капуста,Волк])
s([Коза],L,[Капуста,Волк])
s([],R,[Капуста,Волк,Коза])
searchDpth END

TIME IS 2.2823305130004883

true ;
false.
```
Пример работы поиска в ширину:
```
?- bdth_search(s(['Волк','Коза','Капуста'],'L',[]),s([],'R',[_,_,_])).
searchBdth START
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Капуста],R,[Коза,Волк])
s([Капуста,Коза],L,[Волк])
s([Коза],R,[Волк,Капуста])
s([Коза],L,[Волк,Капуста])
s([],R,[Волк,Капуста,Коза])
searchBdth END

TIME IS 0.0001327991485595703

true ;
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Волк],R,[Коза,Капуста])
s([Волк,Коза],L,[Капуста])
s([Коза],R,[Капуста,Волк])
s([Коза],L,[Капуста,Волк])
s([],R,[Капуста,Волк,Коза])
searchBdth END

TIME IS 1.6134974956512451

true ;
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Капуста],R,[Коза,Волк])
s([Капуста,Коза],L,[Волк])
s([Капуста],R,[Волк,Коза])
s([Капуста,Волк],L,[Коза])
s([Волк],R,[Коза,Капуста])
s([Волк,Коза],L,[Капуста])
s([Коза],R,[Капуста,Волк])
s([Коза],L,[Капуста,Волк])
s([],R,[Капуста,Волк,Коза])
searchBdth END

TIME IS 2.207301139831543

true ;
false.
```
Пример работы поиска с итерационным углублением:
```
?- iter_search(s(['Волк','Коза','Капуста'],'L',[]),s([],'R',[_,_,_])).
iter_search START
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Капуста],R,[Коза,Волк])
s([Капуста,Коза],L,[Волк])
s([Коза],R,[Волк,Капуста])
s([Коза],L,[Волк,Капуста])
s([],R,[Волк,Капуста,Коза])
iter_search END

TIME IS 0.00017690658569335938

true ;
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Волк],R,[Коза,Капуста])
s([Волк,Коза],L,[Капуста])
s([Коза],R,[Капуста,Волк])
s([Коза],L,[Капуста,Волк])
s([],R,[Капуста,Волк,Коза])
iter_search END

TIME IS 1.2022020816802979

true ;
s([Волк,Коза,Капуста],L,[])
s([Волк,Капуста],R,[Коза])
s([Волк,Капуста],L,[Коза])
s([Капуста],R,[Коза,Волк])
s([Капуста,Коза],L,[Волк])
s([Капуста],R,[Волк,Коза])
s([Капуста,Волк],L,[Коза])
s([Волк],R,[Коза,Капуста])
s([Волк,Коза],L,[Капуста])
s([Коза],R,[Капуста,Волк])
s([Коза],L,[Капуста,Волк])
s([],R,[Капуста,Волк,Коза])
iter_search END

TIME IS 2.069587469100952
```

## Выводы

В данной лабораторной работе я изучил различные алгоритмы поиска, а также методы их применения в языке программирования Prolog. Я рассмотрел как их плюсы, так и их минусы. Рассмотренные алгоритмы поиска: поиск в глубину; поиск в ширину; поиск с итерационным углублением.

Из полученных показателей можно сделать вывод, что время работы поиска в ширину и поиска с итерационным углублением примерно сопоставимо. Однако, чтоит заметить, что поиск в ширину требует большего количества памяти O(a^|), где а - коэффициент ветвления, l - количество шагов для решения задачи, что является несомненно его минусом, в то время как поиск в глубину и поиск с итерационным углублением требует памяти O(|).
Но и поиска в ширину есть свои плюсы: он может быстро находить необходимое решение при работе с циклами, а первый найденых правильный путь будет наикратчайшим, что обычно не будет занимать много памяти.

Для разных поставленных задач стоит применять разные пути решения, но если исходить из того, что нам нужно получить как можно больше преимуществ: потратить как можно меньше памяти и времени, то лучше использовать поиск с итерационным углублением. Он является оптимизацией и сочетает в себе лучшее от 2 перечисленных видов: небольшой расход памяти, быстрое время работы. Так и в решении моей задачи я придерживаюсь того мнения, что для решения такой простой задачи, можно использовать именно поиск с итерационным углублением.