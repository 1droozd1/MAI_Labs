# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: <Дубровин Дмитрий Константинович>

## Результат проверки

Вариант задания:

 - [X] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание
1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате [GEDCOM](https://ru.wikipedia.org/wiki/GEDCOM). Для этого рекомендуется использовать сервис [MyHeritage.com](http://myheritage.com), зарегистрировавшись в нем и подключив к заполнению дерева других родственников (указав их контактный e-mail при регистрации, что приведет к автоматической рассылке приглашения на их адрес). Если Вы по каким-то причинам не хотите использовать свою родословную - вы можете использовать файл [родословной европейской знати](http://www.rusgenealog.ru/gedcom/royal_gen.zip).
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя одно из следующих представлений в зависимости от номера в группе в соответствии с формулой ((N-1)+3) mod 4 + 1:\
**Вариант 3**: С использованием предиката `child(ребенок, родитель)`, `male(человек)`, `female(человек)`
3. Реализовать предикат проверки/поиска следующих родственников в соответствии с номером варианта ((N-1) mod 7)+1:\
**Вариант 1**: Шурин
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве, например:
```prolog
?- relative(brother, ‘Петя’, X). 
X = ‘Вася’ 
?- relative(W,’Петя’,’Вася’). 
X = brother 
X = child – father     
% т.е. Вася является ребенком отца Пети 
X = child – mother  
% т.е. Вася является ребенком матери Пети
```

## Получение родословного дерева

В начале, я попытался воспользоваться сервисом MyHeritage.com, однако из-за неработоспособности сервиса мне пришлось искать рабочую альтернативу. Я решил воспользоваться приложением Gramps для платформы Linux. В целом могу заметить, что программа ничем не уступает упомянутому ранее сервису, а в чем-то даже его превосходит. Привожу окно работы программы:

![](https://i.imgur.com/2hJpOb3.png)

## Конвертация родословного дерева

Для получения данных из формата генеологического дерева ged, я решил использовать python, из-за его простоты в парсинге данных. Также я довольно давно пользуюсь и учу данный язык, в связи с чем я не испытывал особенных трудностей в разработке парсера.

Открытие исходного файла и создание словаря для хранения данных:

```
file = open("my_tree.ged", "r", encoding='utf-8')
relative = {}
```

Далее происходит обработка построчно (исходного файла), благодаря удобной функции find довольно просто найти необходимые мне маркеры или же их отсутствие в строке, после чего относительно ID объекта помечаю пол родственника, а также его родственные связи:
```
for string in file.readlines():

    if string.find('INDI') != -1:
        ID = string.split(' ')[1].rstrip()
    elif (string.find('GIVN')) != -1:
        name_and_surname = string.split(' ')[2].rstrip()
    elif string.find('SURN') != -1:
        name_and_surname = name_and_surname + ' ' + string.split(' ')[2].rstrip()
    elif string.find('SEX') != -1:
        if string.split(' ')[2].rstrip() == 'F':
            relative[ID] = [name_and_surname, '-1', '-1', 'female']
        else:
            relative[ID] = [name_and_surname, '-1', '-1', 'male']

    if string.find('HUSB') != -1:
        father = relative[string.split(' ')[2].rstrip()][0]
    elif string.find('WIFE') != -1:
        mother = relative[string.split(' ')[2].rstrip()][0]
    elif string.find('CHIL') != -1:
        relative[string.split(' ')[2].rstrip()][1] = father
        relative[string.split(' ')[2].rstrip()][2] = mother
```
После чего закрываю исходный файл и создаю новый формата pl, куда уже будут вносится будущие предикаты, которые используются далее:

```
file.close()

outfile = open("my_tree.pl", "w")

for i in relative:
    if relative[i][1] != '-1':
        outfile.write("child('" + relative[i][0] + "','" + relative[i][1] + "').\n")
    if relative[i][2] != '-1':
        outfile.write("child('" + relative[i][0] + "','" + relative[i][2] + "').\n")

for i in relative:
    if relative[i][3] == 'male':
        outfile.write(relative[i][3] + "('" + relative[i][0] + "').\n")

for i in relative:
    if relative[i][3] == 'female':
        outfile.write(relative[i][3] + "('" + relative[i][0] + "').\n")

outfile.close()
```

## Предикат поиска родственника

Для проверки условия: является ли N шурином, я использую предикат приведенный ниже. Для начала я проверяю существует ли жены брат от общих родителей, а уже во второй строке проводится проверка мужа с помощью их общего ребенка, а после нужно проверить, что выбранный человек именно мужского пола и не является тем же, что и муж той самой жены.

```
brother_in_law(X, Husband) :-
  child(Wife, Parent), child(X, Parent), 
  child(R, Wife), child(R, Husband), 
  X\= Husband,
  male(X).
```

## Определение степени родства

В начале я написал предикаты для определения ближайших родственников, а также использовал новый предикат check для проверки отношений. В данном фрагменте кода представлен пример на основе проверки мужа:

```
husband(X,Y):-
    child(Z,X),
    child(Z,Y),
    X \= Y,
    male(X).

check(husband,X,Y):- 
    husband(X,Y).
```

Чтобы определить степень родства, я решил использовать поиск в ширину. Для этого предикат accordance изменяет список родственников на список родства с помощью уже ранее добавленного предиката check, предиката add - для добавления элементов родства в список:

```
accordance([_],T,T).
accordance([First,Second|Tail],T,R):-
    check(Relation,First,Second),
    add(Relation,T,X),
    accordance([Second|Tail],X,R),!.

search_in_width(X,Y,P):-
    width([[X]],Y,L),
    reverse(L,P).

width([[Finish|T]|_],Finish,[Finish|T]).

width([Next|B],Finish,Ans):-
    findall(X,prolong(Next,X),T),
    append(B,T,Bn),
    width(Bn,Finish,Ans),!.

width([_|T],Finish,Ans):-
    width(T,Finish,Ans).

relative(X, Y, Z):-
    search_in_width(Y, Z, R),!,
    accordance(R,[] ,X).
```

После проведенного поиск я получаю список родственников, который потом переводится в список родства с помощью accordance.

**Результаты**:

```
?- relative(X,'Дмитрий Дубровин','Татьяна Дубровин').
X = [son].

?- relative(X,'Дмитрий Дубровин','Константин Дубровин').
X = [son].

?- relative(X,'Дмитрий Дубровин','Александра Дубровин').
X = [brother].

```

## Выводы
Исходя из курсового проекта, я обнаружил свой интерес к более детальному изучению генеалогического дерева своей семьи. Теперь я планирую обратиться в архивы, чтобы собрать максимально полную информацию о жизни и достижениях моих предков.

С программной стороны, выполнение курсового проекта позволило мне изучить основы языка программирования Prolog, а также развить свое мышление, так как я рассматривал различные подходы к решению задач. Я справился с парсером и написал первый его вариант для формата GEDCOM. В проекте также использовался алгоритм поиска в ширину. 

Кроме того, выполнение творческого задания курсового проекта, связанного с написанием эссе, привлекло мое внимание к истории развития парадигмы логического программирования, а также к изучению современных систем логического программирования и их преимуществ. Я обнаружил различия между разными системами, их особенности и дальнейшее развитие в области искусственного интеллекта и робототехники.