import random

'''
Сначала нужно рассмотреть подмножество массива и найти в нём максимум 
(или минимум). Затем выбранное значение меняют местами со значением 
первого неотсортированного элемента. Этот шаг нужно повторять до тех пор, 
пока в массиве не закончатся неотсортированные подмассивы.

Худшее время: O(n^2)
Среднее время: O(n^2)
Лучшее время: O(n)

Затраты памяти: O(1)

[29, 10, 14, 37, 13] # Исходный массив
[10, 29, 14, 37, 13] # 10 — минимальный элемент, меняем местами с 29
[10, 13, 14, 37, 29] # 13 — минимальный элемент из [29, 14, 37, 13], меняем местами с 29
[10, 13, 14, 37, 29] # 14 уже на своем месте
[10, 13, 14, 29, 37] # 29 — минимальный элемент из [37, 29], меняем местами с 37
'''

def selection_sort(array):
    # Двигаемся по всему массиву
    for i in range(len(array)):
        # Ищем минимальный элемент в оставшейся части массива
        min_idx = i
        for j in range(i+1, len(array)):
            if array[min_idx] > array[j]:
                min_idx = j
                
        # Меняем местами найденный минимальный элемент с первым элементом
        array[i], array[min_idx] = array[min_idx], array[i]
    return array

# Пример использования
array = [random.randint(0, 100) for i in range(10)]
selection_sort(array)
print("Отсортированный массив:", array)